#ifndef _BMX055_H
#define _BMX055_H

#include "i2c.h"

//	АДРЕС И ID ЧИПА:						//
#define	BMA_ADDRESS				(0x19<<1)   //	Адрес датчика на шине I2C
#define	BMA_ID					0xFA		//	ID датчика
//	РЕГИСТРЫ ЧИПА:							//											|	бит7	|	бит6	|	бит5	|	бит4	|	бит3	|	бит2	|	бит1	|	бит0	|при вкл|	Комментарий
#define	REG_BMA_CHIPID			0x00		//	ID чипа									|											ID<7:0>												| 0xFA	|	ID<7:0>		- значение регистра должно быть равно 0xFA (константа BMA_ID)
#define REG_BMA_X_LSB			0x02		//	Данные углового ускорения по оси X		|					x_lsb<3:0>					| -	- -	- -	- -	- -	- -	- -	- -	- -	|new_data_x	| 0x00	|	x_lsb<3 :0> - младшие биты данных оси X, new_data_x - флаг указывающий на то что данные были обновлены после последнего чтения
#define REG_BMA_X_MSB			0x03		//	Данные углового ускорения по оси X		|					x_msb<11:4>																	| 0x00	|	x_msb<11:4> - старшие биты данных оси X
#define REG_BMA_Y_LSB			0x04		//	Данные углового ускорения по оси Y		|					y_lsb<3:0>					| -	- -	- -	- -	- -	- -	- -	- -	- -	|new_data_y	| 0x00	|	y_lsb<3 :0> - младшие биты данных оси Y, new_data_y - флаг указывающий на то что данные были обновлены после последнего чтения
#define REG_BMA_Y_MSB			0x05		//	Данные углового ускорения по оси Y		|					y_msb<11:4>																	| 0x00	|	y_msb<11:4> - старшие биты данных оси Y
#define REG_BMA_Z_LSB			0x06		//	Данные углового ускорения по оси Z		|					z_lsb<3:0>					| -	- -	- -	- -	- -	- -	- -	- -	- -	|new_data_z	| 0x00	|	z_lsb<3 :0> - младшие биты данных оси Z, new_data_z - флаг указывающий на то что данные были обновлены после последнего чтения
#define REG_BMA_Z_MSB			0x07		//	Данные углового ускорения по оси Z		|					z_msb<11:4>																	| 0x00	|	z_msb<11:4> - старшие биты данных оси Z
#define REG_BMA_TEMP			0x08		//	Данные температуры чипа	в °C			|											temp<7:0>											| 0x00	|	temp<7:0>	- число в формате дополнения до двух с шагом 0.5°С и сдвигом на 23°С вниз. Для получения реальной тепературы нужно данные этого регистра умножить на шаг (0.5°С) и сложить с 23°C. Значение 0x00 соответствует температуре 23°C, значение 0x40 (64) соответствует температуре 55°C, значение 0xC0 (-64) соответствует температуре -9°C.
#define REG_BMA_INT_ST_0		0x09		//	Флаги состояния прерываний				|	flat	|  orient	|   s_tap	|   d_tap	|slo_not_mot|	slope	|	high	|	low		| 0x00	|	flat - датчик ускоряется в направлении одной из осей, orient - смена ориентации ускорения (x/y/z), s_tap - одиночное касание, d_tap - двойное касание, slo_not_mot - медленное движение или неподвижность, slope - наклон, high - высокое ускорение, low - низкое ускорение
#define REG_BMA_INT_ST_1		0x0A		//	Флаги состояния прерываний				|	data	|  fifo_wm	| fifo_full	| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	| 0x00	|	data - готовы новые данные, fifo_wm - буфер заполнен до уровня watermark, fifo_full - буфер полностью заполнен
#define REG_BMA_INT_ST_2		0x0B		//	Флаги состояния прерываний				|  tap_sign	|tap_first_z|tap_first_y|tap_first_x|slope_sign	|slopeFirstZ|slopeFirstY|slopeFirstX| 0x00	|	tap_sign - знак (направление) одиночного/двойного касания, tap_first_z - одиночное/двойное касание по оси Z, tap_first_y - одиночное/двойное касание по оси Y, tap_first_x - одиночное/двойное касание по оси X, slope_sign - знак (направление) наклона, slopeFirstZ - наклон по оси Z, slopeFirstY - наклон по оси Y, slopeFirstX - наклон по оси X
#define REG_BMA_INT_ST_3		0x0C		//	Флаги состояния прерываний				|	flat	|			 orient<2:0>			| high_sign	| highFirstZ| highFirstY| highFirstX| 0x00	|	flat - датчик ускоряется в направлении одной из осей, orient[2] - ориентация ускорения по оси Z («0» вверх, «1» вниз), orient<1:0> - ориентация ускорения по осям XY («00» вертикально вперед; «01» вертикально назаж; «10» горизонтально влево; «11» горизонтально вправо), high_sign знак (направление) высокого ускорения, highFirstZ - высокое ускорение по оси Z, highFirstY - высокое ускорение по оси Y, highFirstX - высокое ускорение по оси X
#define REG_BMA_FIFO_ST			0x0E		//	Статус буфера FIFO						|  overrun	|						fifo_frame_counter<6:0>										| 0x00	|	overrun - произошло переполнение буфера FIFO, fifo_frame_counter<6:0> - размер буфера FIFO (количество кадров хранимых в буфере)
#define REG_BMA_RANGE			0x0F		//	Диапазон измеряемого углового ускорения	| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	|					range<3:0>					| 0xFF	|	range<3:0> - диапазон измеряемого углового ускорения: «0011» ±2g; «0101» ±4g; «1000» ±8g; «1100» ±16g
#define REG_BMA_BW				0x10		//	Полоса пропускания (Bandwidths)			| -	- -	- -	- -	- -	- -	- -	- -	- -	|							bw<4:0>							| 0x0F	|	bw<4:0> - полоса пропускания фильтрованных данных: «00xxx» 7.81 Гц; «01000» 7.81 Гц; «01001» 15.63 Гц; «01010» 31.25 Гц; «01011» 62.5 Гц; «01100» 125 Гц; «01101» 250 Гц; «01110» 500 Гц; «01111» 1000 Гц; «1xxxx» 1000 Гц
#define REG_BMA_LPW				0x11		//	Выбор основных режимов питания			|  suspend	|lowpower_en|deep_suspend|				sleep_dur<3:0>					| -	- -	- -	| 0x00	|	suspend - спящий режим, lowpower_en - режим пониженного энергосбережения, deep_suspend - режим глубокой приостановки. Можно установить только один из флагов suspend, lowpower_en и deep_suspend, а сброс всех трёх флагов в 0 установит нормальный режим. sleep_dur<3:0> - продолжительность фазы ожидания в режиме LOW_POWER (пониженного энергопотребления): «0000»...«0101» 0,5мс; «0110» 1мс; «0111» 2мс; «1000» 4мс; «1001» 6мс; «1010» 10мс; «1011» 25мс; «1100» 50мс; «1101» 100мс; «1110» 500мс; «1111» 1с.
#define REG_BMA_LOW_POWER		0x12		//	Конфигур. низкого энергопотребл.		| -	- -	- -	| lowpower	| sleeptimer| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	| 0x00	|	
#define REG_BMA_D_HBW			0x13		//	Выбор типа данных и их затенение		|dataHigh_bw| shadow_dis| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	| 0x00	|	dataHigh_bw: «1» получение нефильтрованных данных; «0» получение фильтрованных данных, shadow_dis: «1» отключить / «0» включить механизм затенения регистров вывода данных углового ускорения. (затенение обеспечивает целостность данных, блокируя запись новых данных в старшие биты (MSB) если началось чтение младших битов (LSB), до тех пор пока не будут прочитаны старшие биты (MSB) данных углового ускорения).
#define REG_BMA_RESET			0x14		//	Программная перезагрузка				|											softreset<7:0>										| 0x00	|	Запись значения 0xB6 приведёт к перезагрузке и сбросу регистров.
#define REG_BMA_INT_EN_0		0x16		//	Флаги разрешения прерываний				|  flat_en	| orient_en	| s_tap_en	| d_tap_en	| -	- -	- -	| slope_en_z| slope_en_y| slope_en_x| 0x00	|	flat_en - разрешает прерывание отслеживающее ускорение датчика в направлении одной из осей, orient_en - разрешает прерывания по смене ориентации ускорения, s_tap_en - разрешает прерывание по одиночному касанию, d_tap_en - разрешает прерывание по двойному касанию, slope_en_z - разрешает прерывание фиксирующее наклон по оси z, slope_en_y - разрешает прерывание фиксирующее наклон по оси y, slope_en_x - разрешает прерывание фиксирующее наклон по оси x
#define REG_BMA_INT_EN_1		0x17		//	Флаги разрешения прерываний				| -	- -	- -	|  f_wm_en	| f_full_en	|  data_en	|  low_en	| high_en_z	| high_en_y	| high_en_x	| 0x00	|	f_wm_en - разрешает прерывание по заполнению буфера fifo до уровня (watermark), f_full_en - разрешает прерывание по полному заполнению буфера fifo, data_en - разрешает прерывание по поступлению новых данных, low_en - разрешает прерывание фиксирующее низкое ускорение, high_en_z - разрешает прерывание фиксирующее высокое ускорение по оси z, high_en_y - разрешает прерывание фиксирующее высокое ускорение по оси y, high_en_x - разрешает прерывание фиксирующее высокое ускорение по оси x
#define REG_BMA_INT_EN_2		0x18		//	Флаги разрешения прерываний				| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	|sloNoMotSel|sloNoMotEnZ|sloNoMotEnY|sloNoMotEnX| 0x00	|	sloNoMotSel - выбор режима работы прерывания фиксирующего медленное движение или неподвижность («0» медленное движение; «1» неподвижность), sloNoMotEnZ - разрешает прерывание фиксирующее медленное движение или неподвижность по оси z, sloNoMotEnY - разрешает прерывание фиксирующее медленное движение или неподвижность по оси y, sloNoMotEnX - разрешает прерывание фиксирующее медленное движение или неподвижность по оси x
#define REG_BMA_INT_MAP_0		0x19		//	Флаги направляющие прерывания на INT1	| int1_flat	|int1_orient| int1_s_tap| int1_d_tap|int1SloNoMot|int1_slope| int1_high	| int1_low	| 0x00	|	int1_flat - направить прерывание по ускорению датчика в направлении одной из осей на вывод INT1, int1_orient - направить прерывание по смене ориентации ускорения на вывод INT1, int1_s_tap - направить прерывание по одиночному касанию на вывод INT1, int1_d_tap - направить прерывание по двойному касанию на вывод INT1, int1SloNoMot - направить прерывание по медленному движению или неподвижности на вывод INT1, int1_slope - направить прерывание по наклону на вывод INT1, int1_high - направить прерывание по высокому ускорению на вывод INT1, int1_low - направить прерывание по низкому ускорению на вывод INT1
#define REG_BMA_INT_MAP_1		0x1A		//	Флаги направл-е прерывания на INT1,INT2	| int2_data	|int2_f_wm	|int2_f_full| -	- -	- -	| -	- -	- -	|int1_f_full| int1_f_wm	| int1_data	| 0x00	|	int2_data - направить прерывание по готовности новых данных на вывод INT2, int2_f_wm - направить прерывание по заполнению буфера fifo до уровня (watermark) на вывод INT2, int2_f_full - направить прерывание по переполнению буфера fifo на вывод INT2, int1_f_full - направить прерывание по переполнению буфера fifo на вывод INT1, int1_f_wm - направить прерывание по заполнению буфера fifo до уровня (watermark) на вывод INT1, int1_data - направить прерывание по готовности новых данных на вывод INT1
#define REG_BMA_INT_MAP_2		0x1B		//	Флаги направляющие прерывания на INT2	| int2_flat	|int2_orient| int2_s_tap| int2_d_tap|int2SloNoMot|int2_slope| int2_high	| int2_low	| 0x00	|	int2_flat - направить прерывание по ускорению датчика в направлении одной из осей на вывод INT2, int2_orient - направить прерывание по смене ориентации ускорения на вывод INT2, int2_s_tap - направить прерывание по одиночному касанию на вывод INT2, int2_d_tap - направить прерывание по двойному касанию на вывод INT2, int2SloNoMot - направить прерывание по медленному движению или неподвижности на вывод INT2, int2_slope - направить прерывание по наклону на вывод INT2, int2_high - направить прерывание по высокому ускорению на вывод INT2, int2_low - направить прерывание по низкому ускорению на вывод INT2
#define REG_BMA_INT_SRC			0x1E		//	Тип данных используемых для прерываний	| -	- -	- -	- -	- -	- -	| src_data	| src_tap	|srcSloNoMot| src_slope	| src_high	|  src_low	| 0x00	|	Источником данных для соответствующих прерываний будут: «0» фильтрованные данные; «1» нефильтрованные данные
#define REG_BMA_INT_OUT_CTRL	0x20		//	Выбор поведения выводов INT1 и INT2		| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	|  int2_od	|  int2_lvl	|  int1_od	| int1_lvl	| 0x05	|	int2_od - выбор типа схемы для вывода INT2 («0» комплиментарная (push-pull); «1» открытый сток), int2_lvl - активный уровень на выводе INT2, int1_od - выбор типа схемы для вывода INT1 («0» комплиментарная (push-pull); «1» открытый сток), int1_lvl - активный уровень на выводе INT1
#define REG_BMA_INT_RST_LATCH	0x21		//	Выбор режима и сброс прерываний			| reset_int	| -	- -	- -	- -	- -	- -	- -	- -	- -	|					latch_int<3:0>				| 0x00	|	reset_int - установка в «1» приведёт к сбросу активных прерываний, latch_int<3:0> - определяет режим прерываний фиксированный, не фиксированный, или временный.
#define REG_BMA_INT_0			0x22		//	Значения для прерывания низк. ускорения	|											low_dur<7:0>										| 0x09	|	low_dur<7:0> - время задержки для прерывания фиксирующего низкое ускорение = (low_dur<7:0> + 1) * 2мс. Прерывание сработает если низкое ускорение фиксируется дольше времени зарержки. Из приведённой формулы получается что время задержки можно установить от 2 до 512 мс., значение по умолчанию 20 мс.
#define REG_BMA_INT_1			0x23		//	Значения для прерывания низк. ускорения	|											low_th<7:0>											| 0x30	|	low_th<7:0> - порог срабатывания для прерывания фиксирующего низкое ускорение = low_th<7:0> * 7.81мg. Прерывание сработает если фиксируемое ускорение ниже указанного порога. Из приведённой формулы получается что порог срабатывания можно установить от 0 до 1,992 g., значение по умолчанию 375 g.
#define REG_BMA_INT_2			0x24		//	Значения для низк. и высок. ускорения	|		high_hy<1:0>	| -	- -	- -	- -	- -	- -	- -	- -	- -	| low_mode	|		low_hy<1:0>		| 0x81	|	low_mode - режим работы прерывания низкого ускорения: «0» для прерывания учитываются данные каждой оси по отдельности; «1» для прерывания учитывается сумма всех осей, high_hy<1:0> - гистерезис прерывания фиксирующего высокое ускорение = high_hy<1:0> * 62.5мg * (диапазон измеряемого ускорения range<3:0> в g), low_hy<1:0> - гистерезис прерывания фиксирующего низкое ускорение = low_hy<1:0> * 125мg (независимо от диапазона измеряемого ускорения range<3:0>),
#define REG_BMA_INT_3			0x25		//	Значения для прерывания высок. ускорения|											high_dur<7:0>										| 0x0F	|	high_dur<7:0> - время задержки для прерывания фиксирующего высокое ускорение = (high_dur<7:0> + 1) * 2мс. Прерывание сработает если высокое ускорение фиксируется дольше времени зарержки. Из приведённой формулы получается что время задержки можно установить от 2 до 512 мс., значение по умолчанию 32 мс.
#define REG_BMA_INT_4			0x26		//	Значения для прерывания высок. ускорения|											high_th<7:0>										| 0xC0	|	high_th<7:0> - порог срабатывания для прерывания фиксирующего высокое ускорение = high_th<7:0> * 3.905мg * (диапазон измеряемого ускорения: range<3:0> в g = ±2;±4;±8;±16), результат в мg. Прерывание сработает если фиксируемое ускорение выше указанного порога.
#define REG_BMA_INT_5			0x27		//	Значения для прерываний	наклона и ...	|							slo_no_mot_dur<5:0>							|	slope_dur<1:0>		| 0x00	|	slope_dur<1:0> - время задержки для прерывания фиксирующего наклон = slope_dur <1:0> + 1мс, slo_no_mot_dur<5:0> - зависит от бита sloNoMotSel: если sloNoMotSel=«0» то slo_no_mot_dur<1:0> (два бита!) должны быть выше порога срабатывания (slo_no_mot_th<7:0>) для прерывания фиксирующего медленное движение; если sloNoMotSel=«1» то slo_no_mot_dur<5:0> определяет время срабатывания для прерывания фиксирующего отсутствие движения (если slo_no_mot_dur<5:4>=«00» то время = slo_no_mot_dur<3:0> + 1мс, если slo_no_mot_dur<5:4>=«b01» то время = slo_no_mot_dur<3:0> * 4 + 20мс, если slo_no_mot_dur<5>=«1» то время = slo_no_mot_dur<4:0> * 8 + 88мс., 
#define REG_BMA_INT_6			0x28		//	Значения для прерывания наклона			|											slope_th<7:0>										| 0x14	|	slope_th<7:0> - порог срабатывания для прерывания фиксирующего наклон = slope_th<7:0> * 1.955 мg * (диапазон измеряемого ускорения: range<3:0> в g = ±2;±4;±8;±16), результат в мg. Прерывание сработает если фиксируемый наклон выше указанного порога.
#define REG_BMA_INT_7			0x29		//	Значения для прерывания медл. движения	|										slo_no_mot_th<7:0>										| 0x14	|	slo_no_mot_th<7:0> - порог срабатывания для прерывания медленного движения = slo_no_mot_th<7:0> * 1.955 мg * (диапазон измеряемого ускорения: range<3:0> в g = ±2;±4;±8;±16), результат в мg. Прерывание сработает если фиксируемое движение ниже указанного порога.
#define REG_BMA_INT_8			0x2A		//	Значения для одиночного/двойного касания| tap_quiet	| tap_shock	| -	- -	- -	- -	- -	- -	- -	- -	- -	|			tap_dur<2:0>			| 0x04	|	tap_quiet - длительность слабого однократного касания: «0» 30мс; «1» 20мс, tap_shock - длительность сильного однократного касания: «0» 50мс; «1» 70мс, tap_dur<2:0> - время задержки между двойным касанием = «000b» 50мс; «001b» 100мс; «010b» 150мс; «011b» 200мс; «100b» 250мс; «101b» 375мс; «110b» 500мс; «111b» 700мс.
#define REG_BMA_INT_9			0x2B		//	Значения для одиночного/двойного касания|	tap_samp<1:0>		| -	- -	- -	|						tap_th<4:0>							| 0x0A	|	tap_samp<1:0> - количество выборок данных для определения двойного/одиночного касания в режиме (lowpower) пониженного энергопотребления: «00b» 2 выборки; «01» 4 выборки; «10» 8 выборок; «11» 16 выборок, tap_th<4:0> - порог срабатывания для прерывания фиксирующего двойное/одиночное касание = tap_th<3:0> * 31.25 * (диапазон измеряемого ускорения: range<3:0> в g = ±2;±4;±8;±16), результат в мg. Прерывание сработает если фиксируемые касания выше указанного порога.
#define REG_BMA_INT_A			0x2C		//	Значения для прерывания ориентации		| -	- -	- -	|			orient_hyst<2:0>		|  orient_blocking<1:0>	|	orient_mode<1:0>	| 0x18	|	
#define REG_BMA_INT_B			0x2D		//	Значения для прерывания ориентации		| -	- -	- -	|orient_ud_en|							orient_theta<5:0>							| 0x48	|	
#define REG_BMA_INT_C			0x2E		//	Значения для прерывания в одной плоск.	| -	- -	- -	- -	- -	- -	|							flat_theta<5:0>								| 0x08	|	
#define REG_BMA_INT_D			0x2F		//	Значения для прерывания в одной плоск.	| -	- -	- -	- -	- -	- -	|  flat_hold_time<1:0>	| -	- -	- -	|			flat_hy[2:0]			| 0x11	|	
#define REG_BMA_FIFO_CONFIG_0	0x30		//	Уровень watermark для буфера fifo		| -	- -	- -	- -	- -	- -	|			fifo_water_mark_level_trigger_retain<5:0>					| 0x00	|	fifo_water_mark_level_trigger_retain<5:0> - уровень watermark для буфера FIFO. Как только буфер заполнится до этого уровня - сработает прерывание fifo_wm если оно разрешено флагом f_wm_en
#define REG_BMA_PMU_SELF_TEST	0x32		//	Настройка и запуск самотестирования		| -	- -	- -	- -	- -	- -	- -	- -	- -	|s_test_amp	| -	- -	- -	|s_test_sign|  self_test_axis<1:0>	| 0x00	|	s_test_amp - флаг выбора амплитуды самотестирования (в библиотеке используется высокая амплитуда): «1» высокая; «0» низкая, s_test_sign - флаг выбора знака (направления прилагаемой электростатической силы) самотестирования: «1» положительный; «0» отрецательный, self_test_axis<1:0> - выбор оси для самотестирования: «00» нет (самотестирование отключено); «01» ось X; «10» ось Y; «11» ось Z; после выбора оси начнётся самотестирование на что датчику требуется не менее 50мс.
#define REG_BMA_TRIM_NVM_CTRL	0x33		//	Настройка энергонезависимой памяти NVM	|				nvm_remain<3:0>					| nvm_load	|  nvm_rdy	| nvm_trig	| nvm_mode	| 0xF0	|	nvm_remain<3:0> - количество оставшихся циклов записи в NVM (многократно программируемую энергонезависимую память), nvm_load - флаг разрешающий обновление всех конфигурационных регистров из NVM памяти, nvm_rdy - флаг состояния готовности памяти NVM у записи: «0» выполняется запись (обновление) NVM; «1» память NVM готова принять новые тданные для записи, nvm_trig - флаг запускающий опреацию записи в NVM: «1» запуск; «0» нет, nvm_mode - флаг разблокировки записи в NVM: «1» запись разрешена (разблокирована); «0» запись запрещена (заблокирована).
#define REG_BMA_BGW_SPI3_WDT	0x34		//	Настройки для цифровых интерфейсов		| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	| i2c_wdt_en|i2c_wdt_sel|	spi3	| 0x00	|	i2c_wdt_en - флаг активации сторожевого таймера WDT на выводе SDA для шины I2C: «1» активен; «0» отключён, i2c_wdt_sel - выбор периода ожидания для сторожевого таймера на шине I2C: «0» 1 мс; «1» 50 мс, spi3 - флаг выбора 3-проводного режима шины SPI: «1» 3-проводной режим; «0» 4-проводный режим.
#define REG_BMA_OFC_CTRL		0x36		//	Управлен. вычислением компенс. смещения	|offset_reset|	cal_trigger<1:0>	|  cal_rdy	| -	- -	- -	|  hp_z_en	|  hp_y_en	|  hp_x_en	| 0x10	|	offset_reset - флаг сброса значений регистров смещения: «1» сбросить регистры смещения (0x38 - 0x3A) в ноль; «0» хранить значения регистров смещения, cal_trigger<1:0> - выполнить быстрое вычисление компенсации смещения для: «01» оси X; «10» осиY; «11» оси Z; «00» не выполнять быстрое вычисление компенсации смещения; (быстрое вычисление компенсации смещения не должно вызываться при сброшенном флаге cal_rdy), cal_rdy - флаг указывающий о готовности чипа к новому быстрому вычислению компенсации смещения: «1» готов; «0» не готов, hp_z_en - флаг запускающий медленное вычисление компенсации смещения по оси Z: «1» запустить; «0» не запускать, hp_y_en - флаг запускающий медленное вычисление компенсации смещения по оси Y: «1» запустить; «0» не запускать, hp_x_en - флаг запускающий медленное вычисление компенсации смещения по оси X: «1» запустить; «0» не запускать.
#define REG_BMA_OFC_SETTING		0x37		//	Настройки вычисления компенс. смещения	| -	- -	- -	| offset_target_z<1:0>	| offset_target_y<1:0>	| offset_target_x<1:0>	|  cut_off	| 0x00	|	offset_target_z<1:0> - установить значение компенсации для оси Z в: «00» 0g.; «01» +1g.; «10» -1g.; «11» 0g., offset_target_y<1:0> - установить значение компенсации для оси Y в: «00» 0g.; «01» +1g.; «10» -1g.; «11» 0g., offset_target_x<1:0> - установить значение компенсации для оси X в: «00» 0g.; «01» +1g.; «10» -1g.; «11» 0g., cut_off - граничная частота фильтра для медленного вычисления компенсации смещения: «0» 1Гц; «1» 10Гц
#define REG_BMA_OFC_OFFSET_X	0x38		//	Значение компенсации смещения по оси X	|										offset_x<7:0>											| 0x00	|	offset_x<7:0> - значение компенсации смещения для данных углового ускорения считываемых по оси X. Значение смещения добавляется к подученным фильтрованным и нефильтрованным данным ускорения; Значение смещения представляется в виде числа в коде дополнения двух от -128 (-1g) до +127 (+0,992g) и не зависит от выбранного диапазона измерений; Содержимое этого регистра может быть записано в NVM (от куда будет автоматически восстанавливается после каждого включения питания или программной перезагрузки), или может быть вычислено (быстрым или медленным способом) результат вычислений записывается в регистр автоматически по завершении вычислений, или записано пользователем.
#define REG_BMA_OFC_OFFSET_Y	0x39		//	Значение компенсации смещения по оси Y	|										offset_y<7:0>											| 0x00	|	offset_y<7:0> - значение компенсации смещения для данных углового ускорения считываемых по оси Y. Значение смещения добавляется к подученным фильтрованным и нефильтрованным данным ускорения; Значение смещения представляется в виде числа в коде дополнения двух от -128 (-1g) до +127 (+0,992g) и не зависит от выбранного диапазона измерений; Содержимое этого регистра может быть записано в NVM (от куда будет автоматически восстанавливается после каждого включения питания или программной перезагрузки), или может быть вычислено (быстрым или медленным способом) результат вычислений записывается в регистр автоматически по завершении вычислений, или записано пользователем.
#define REG_BMA_OFC_OFFSET_Z	0x3A		//	Значение компенсации смещения по оси Z	|										offset_z<7:0>											| 0x00	|	offset_z<7:0> - значение компенсации смещения для данных углового ускорения считываемых по оси Z. Значение смещения добавляется к подученным фильтрованным и нефильтрованным данным ускорения; Значение смещения представляется в виде числа в коде дополнения двух от -128 (-1g) до +127 (+0,992g) и не зависит от выбранного диапазона измерений; Содержимое этого регистра может быть записано в NVM (от куда будет автоматически восстанавливается после каждого включения питания или программной перезагрузки), или может быть вычислено (быстрым или медленным способом) результат вычислений записывается в регистр автоматически по завершении вычислений, или записано пользователем.
#define REG_BMA_TRIM_GPO		0x3B		//	Регистр памяти NVM общего назначения	|											GP0<7:0>											| 0x00	|	GP0<7:0> - данные этого регистра могут быть записаны в NVM (многократно программируемую энергонезависимую память) и будут восстанавливаться из неё в этот регистр при каждом включении или программной перезагрузке. Регистр не несёт какой либо функциональности и может быть использован пользователем
#define REG_BMA_TRIM_GP1		0x3C		//	Регистр памяти NVM общего назначения	|											GP1<7:0>											| 0x00	|	GP1<7:0> - данные этого регистра могут быть записаны в NVM (многократно программируемую энергонезависимую память) и будут восстанавливаться из неё в этот регистр при каждом включении или программной перезагрузке. Регистр не несёт какой либо функциональности и может быть использован пользователем
#define REG_BMA_FIFO_CONFIG_1	0x3E		//	Настройки конфигурации буфера FIFO		|	fifo_mode<1:0>		| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	| fifo_data_select<1:0>	| 0x00	|	fifo_mode<1:0> - выбор режима работы буфера FIFO: «00» BYPASS (глубина буфера 1 кадр, старые данные стираются); «01» FIFO (сбор данных прекращается при полном заполнении буфера - 32 кадра); «10» STREAM (сбор данных продолжается при полном заполнении буфера, старые кадры стираются), fifo_data_select<1:0> - выбор данных для буфера FIFO: «00» собираются данные всех осей XYZ; «01» собираются данные только оси X; «10» собираются данные только оси Y; «11» собираются данные только оси Z. При записи данных в регистр FIFO_CONFIG_1, память FIFO буфера и флаг fifo-full очищается.
#define REG_BMA_FIFO_DATA		0x3F		//	Регистр чтения данных из буфера FIFO	|										fifo_data<7:0>											| 0x00	|	fifo_data<7:0> - байт для чтения данных из буфера FIFO. Данные буфера FIFO хранятся кадрами (объём буфера равен 32 кадра). Состав кадра зависит от значения битов fifo_data_select<1:0> регистра REG_BMA_FIFO_CONFIG_1: Если выбраны данные всех осей XYZ, то каждый кадр считывается побайтно в следующем порядке X-lsb, X-msb, Y-lsb, Y-msb, Z-lsb, Z-msb; Если выбраны данные только оси X, то каждый кадр считывается побайтно в следующем порядке X-lsb, X-msb; Если выбраны данные только оси Y или только оси Z, то каждый кадр считывается побайтно, как и для оси X. Если чтение буфера остановлено и кадр считан не полностью, то при следующей инициализации чтения в fifo_data<7:0> будет находиться пербый байт следующего кадра.


class BMX055
{
public:
    BMX055(I2c *i2c);
  
    uint8_t readReg(uint8_t reg);
    bool writeReg(uint8_t reg, uint8_t value);
    
    bool isValid() const {return m_valid;}
    bool readAcc();
    
    float accX() const {return m_value[0];}
    float accY() const {return m_value[1];}
    float accZ() const {return m_value[2];}
    
private:
    I2c *m_dev;
    bool m_valid;
    
    void setFastOffset();
    
public:
    int16_t m_acc[3];
    float m_value[3];
    
};


#endif